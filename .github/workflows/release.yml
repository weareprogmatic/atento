name: Release Workflow

on:
  # Triggers on push to main
  push:
    branches: [main]
  # Allows manual runs for testing
  workflow_dispatch:

env:
  # Use the standard GITHUB_TOKEN for actions requiring repo write/read access
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Variable to hold the calculated new version
  NEW_VERSION: ""

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
    permissions:
      contents: write # Needed for committing, pushing tags, and creating releases

    steps:
      # ------------------------------
      # 1. Checkout & Setup Rust
      # ------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # IMPORTANT: Fetch all history and tags for versioning logic

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install tools
        run: cargo install cargo-edit

      # --- Code Quality: rustfmt (Style Check) ---
      - name: 📝 Run cargo fmt check
        run: cargo fmt --all --check
        # The '--check' flag ensures the job fails if formatting is required.
 
      # --- Code Quality: clippy (Linting) ---
      - name: 🧹 Run cargo clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
        # The '-D warnings' flag makes the CI fail on any warning.

      # --- Code Coverage (using cargo-tarpaulin) ---
      - name: 🚀 Install cargo-tarpaulin
        run: cargo install cargo-tarpaulin

      - name: 🧪 Run tests and collect coverage
        run: cargo tarpaulin --verbose --out Xml --ignore-tests
        # Tarpaulin defaults to placing the XML report here:
        # target/tarpaulin/cobertura.xml

      - name: 📝 Publish Coverage Report to GitHub Summary 🚀
        uses: MishaKav/pytest-coverage-comment@main
        with:
          # The path to the Cobertura XML file generated by tarpaulin
          coverage-path: target/tarpaulin/cobertura.xml
          # Set report format to cobertura
          coverage-format: cobertura
          # Optional: Define minimum coverage percentage to pass the check
          minimum-coverage: 80
          # Optional: Comment mode (default is 'replace')
          title: Code Coverage Report 📈

      # run all unit tests for the workspace
      - name: Run unit tests and check code quality
        run: cargo test --workspace --lib --all-features

      # ------------------------------
      # 2. Determine and Bump Version (Commit-based Conventional Commit Analysis)
      # ------------------------------
      - name: Determine bump type
        id: bump_version
        run: |          
          # 1. Find the last tag to look for changes since
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last Tag: $LAST_TAG"

          # 2. Analyze commits since the last tag for Conventional Commit type
          COMMIT_LOG=$(git log --pretty=format:%s $LAST_TAG..HEAD)
          BUMP_TYPE="patch"

          if echo "$COMMIT_LOG" | grep -q "BREAKING CHANGE"; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_LOG" | grep -q "^feat"; then
            BUMP_TYPE="minor"
          elif echo "$COMMIT_LOG" | grep -q "^fix"; then
            BUMP_TYPE="patch"
          fi
          
          # Fallback if no specific type is found, ensure a bump happens for the push.
          if [ "$BUMP_TYPE" == "patch" ] && ! echo "$COMMIT_LOG" | grep -qE "^feat|^fix"; then
              BUMP_TYPE="patch"
          fi

          echo "Determined Bump Type: $BUMP_TYPE"

          # Strip the 'v' prefix and remove any trailing control characters (like \r)
          VERSION_CLEANED="${LAST_TAG#v}"
          VERSION_CLEANED=$(echo "$VERSION_CLEANED" | tr -d '\r') # Use tr to strip \r

          # 3. Calculate the new version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_CLEANED"
 
          # Explicitly remove leading zeros and ensure default is 0
          MAJOR=$((10#${MAJOR:-0}))
          MINOR=$((10#${MINOR:-0}))
          PATCH=$((10#${PATCH:-0}))

          case $BUMP_TYPE in
            patch) PATCH=$((PATCH + 1));;
            minor) MINOR=$((MINOR + 1)); PATCH=0;;
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT 
          echo "Calculated New Version: $NEW_VERSION"

      # 3. Bump versions in Cargo.toml files
      - name: Bump versions
        run: |
          cargo set-version $NEW_VERSION --manifest-path atento-core/Cargo.toml
          cargo set-version $NEW_VERSION --manifest-path atento-cli/Cargo.toml

  # --- Build Jobs Now Depend on the Tag being Pushed ---
  # These jobs should now be triggered by the new tag push (if you add a tag trigger), 
  # but since they depend on the 'release' job, they will run immediately.
  build-linux-windows:
    # Use condition to only run if a new version was set and the current ref is 'main'
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: ubuntu-latest
    env:
      NEW_VERSION: ${{ needs.release.outputs.new_version }}    
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable          
          override: true
      - run: cargo install cross
      # Linux builds
      - run: cross build --release --target x86_64-unknown-linux-musl --bin atento-cli --target-dir target/x86_64-unknown-linux-musl
      - run: cross build --release --target aarch64-unknown-linux-musl --bin atento-cli --target-dir target/aarch64-unknown-linux-musl
      # Windows builds
      - run: cross build --release --target x86_64-pc-windows-gnu --bin atento-cli --target-dir target/x86_64-pc-windows-gnu
      # Rename binaries
      - run: |
          for dir in target/*/*/release; do
            for file in $dir/atento-cli*; do
              mv "$file" "${file/atento-cli/atento}"
            done
          done
      - name: Upload binaries
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.target }}
          path: target/*/*/release/atento*
          
  build-macos:
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: macos-latest
    env:
      NEW_VERSION: ${{ needs.release.outputs.new_version }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - run: cargo build --release --target aarch64-apple-darwin --bin atento-cli --target-dir target/aarch64-apple-darwin
      - run: |
          for dir in target/*/*/release; do
            if ls $dir/atento-cli* 1> /dev/null 2>&1; then
              for file in $dir/atento-cli*; do
                mv "$file" "${file/atento-cli/atento}"
              done
            else
              echo "⚠️ No binaries found in $dir, skipping."
            fi
          done

  create-release:
    if: success() && github.ref == 'refs/heads/main'
    needs: [build-linux-windows, build-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write # Ensure permissions are set here too, or globally at the job level

    steps:
      - uses: actions/checkout@v4
      
      - name: Set NEW_VERSION for current job
        run: |
          echo "NEW_VERSION=${{ needs.release.outputs.NEW_VERSION }}" >> $GITHUB_ENV
          
      # 💡 FIX A: Download all artifacts from the build jobs
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts into their respective directories
          path: artifacts/

      - name: Commit & push version bump 
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          cargo set-version $NEW_VERSION --manifest-path atento-core/Cargo.toml
          cargo set-version $NEW_VERSION --manifest-path atento-cli/Cargo.toml

          git add atento-core/Cargo.toml atento-cli/Cargo.toml
          
          # 💡 CRITICAL FIX: Add '--allow-empty' OR check for changes before committing.
          # The safer method is to use git commit's error handling:
          git commit -m "chore(release): Bump version to v$NEW_VERSION" || echo "No changes to commit."
          
          # Note: If no commit was made, the push won't have the new commit, but the tag push will still fail if the tag already exists.
          # The entire step needs to be robust:

          # A safer, multi-line shell script:
          set +e # Temporarily allow errors (for git commit)
          
          # Commit changes (if any)
          git commit -m "chore(release): Bump version to v$NEW_VERSION" 
          COMMIT_EXIT_CODE=$?
          
          set -e # Re-enable error on failure

          if [ $COMMIT_EXIT_CODE -ne 0 ] && [ $COMMIT_EXIT_CODE -ne 1 ]; then
              # Only fail if the exit code is not 0 (success) or 1 (nothing to commit)
              exit $COMMIT_EXIT_CODE
          elif [ $COMMIT_EXIT_CODE -eq 0 ]; then
              echo "Changes committed. Pushing..."
              # Only push the commit if a new one was actually created (exit code 0)
              git push origin main

              git tag v$NEW_VERSION --force # Use --force if you want to overwrite, but generally discouraged
              git push origin v$NEW_VERSION

          else
              echo "No changes detected by git commit. Skipping commit push."
          fi

      # ------------------------------
      # Publish Crate
      # ------------------------------
      - name: Publish core to crates.io
        run: cargo publish --manifest-path atento-core/Cargo.toml --allow-dirty
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_TOKEN }}

      # We need the tag to exist before creating the release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          name: "Release v${{ env.NEW_VERSION }}"
          # Get all built artifacts to attach to the release
          files: target/*/*/release/atento*
