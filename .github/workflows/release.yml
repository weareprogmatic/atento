name: Release Workflow

on:
  # Triggers on push to main
  push:
    branches: [main]
  # Allows manual runs for testing
  workflow_dispatch:

env:
  # Use the standard GITHUB_TOKEN for actions requiring repo write/read access
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Variable to hold the calculated new version
  NEW_VERSION: ""

jobs:
  release:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.bump_version.outputs.new_version }}
    permissions:
      contents: write # Needed for committing, pushing tags, and creating releases

    steps:
      # ------------------------------
      # 1. Checkout & Setup Rust
      # ------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # IMPORTANT: Fetch all history and tags for versioning logic

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install tools
        run: cargo install cargo-edit

      # --- Code Quality: rustfmt (Style Check) ---
      - name: üìù Run cargo fmt check
        run: cargo fmt --all --check
        # The '--check' flag ensures the job fails if formatting is required.
 
      # --- Code Quality: clippy (Linting) ---
      - name: üßπ Run cargo clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
        # The '-D warnings' flag makes the CI fail on any warning.

      # --- Code Coverage (using cargo-tarpaulin) ---
      - name: üöÄ Install cargo-tarpaulin
        run: cargo install cargo-tarpaulin

      - name: üß™ Run tests and collect coverage
        run: cargo tarpaulin --verbose --out Xml --ignore-tests
        # Tarpaulin defaults to placing the XML report here:
        # target/tarpaulin/cobertura.xml

      - name: üìù Publish Coverage Report to GitHub Summary üöÄ
        uses: MishaKav/pytest-coverage-comment@main
        with:
          # The path to the Cobertura XML file generated by tarpaulin
          coverage-path: target/tarpaulin/cobertura.xml
          # Set report format to cobertura
          coverage-format: cobertura
          # Optional: Define minimum coverage percentage to pass the check
          minimum-coverage: 80
          # Optional: Comment mode (default is 'replace')
          title: Code Coverage Report üìà

      # run all unit tests for the workspace
      - name: Run unit tests and check code quality
        run: cargo test --workspace --lib --all-features

      # ------------------------------
      # 2. Determine and Bump Version (Commit-based Conventional Commit Analysis)
      # ------------------------------
      - name: Determine bump type
        id: bump_version
        run: |          
          # 1. Find the last tag to look for changes since
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last Tag: $LAST_TAG"

          # 2. Analyze commits since the last tag for Conventional Commit type
          COMMIT_LOG=$(git log --pretty=format:%s $LAST_TAG..HEAD)
          BUMP_TYPE="patch"

          if echo "$COMMIT_LOG" | grep -q "BREAKING CHANGE"; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_LOG" | grep -q "^feat"; then
            BUMP_TYPE="minor"
          elif echo "$COMMIT_LOG" | grep -q "^fix"; then
            BUMP_TYPE="patch"
          fi
          
          # Fallback if no specific type is found, ensure a bump happens for the push.
          if [ "$BUMP_TYPE" == "patch" ] && ! echo "$COMMIT_LOG" | grep -qE "^feat|^fix"; then
              BUMP_TYPE="patch"
          fi

          echo "Determined Bump Type: $BUMP_TYPE"

          # Strip the 'v' prefix and remove any trailing control characters (like \r)
          VERSION_CLEANED="${LAST_TAG#v}"
          VERSION_CLEANED=$(echo "$VERSION_CLEANED" | tr -d '\r') # Use tr to strip \r

          # 3. Calculate the new version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_CLEANED"
 
          # Explicitly remove leading zeros and ensure default is 0
          MAJOR=$((10#${MAJOR:-0}))
          MINOR=$((10#${MINOR:-0}))
          PATCH=$((10#${PATCH:-0}))

          case $BUMP_TYPE in
            patch) PATCH=$((PATCH + 1));;
            minor) MINOR=$((MINOR + 1)); PATCH=0;;
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_OUTPUT 
          echo "Calculated New Version: $NEW_VERSION"

      # 3. Bump versions in Cargo.toml files
      - name: Bump versions
        run: |
          cargo set-version $NEW_VERSION --manifest-path atento-core/Cargo.toml
          cargo set-version $NEW_VERSION --manifest-path atento-cli/Cargo.toml

  build-linux-windows:
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - target: x86_64-unknown-linux-musl
          - target: aarch64-unknown-linux-musl
          - target: x86_64-pc-windows-gnu
    env:
      NEW_VERSION: ${{ needs.release.outputs.new_version }}

    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - run: cargo install cross

      - name: Build for ${{ matrix.target }}
        run: cross build --release --target ${{ matrix.target }} --bin atento-cli

      - name: Rename binary to "atento"
        run: |
          shopt -s nullglob
          BIN_DIR="target/${{ matrix.target }}/release"
          if compgen -G "$BIN_DIR/atento-cli*" > /dev/null; then
            for file in "$BIN_DIR"/atento-cli*; do
              mv "$file" "${file/atento-cli/atento}"
            done
          else
            echo "‚ö†Ô∏è No binaries found in $BIN_DIR"
            ls -R target || true
          fi

      - name: Upload binary
        uses: actions/upload-artifact@v4
        with:
          name: atento-${{ matrix.target }}-${{ env.NEW_VERSION }}
          path: target/${{ matrix.target }}/release/atento*
          if-no-files-found: error

  build-macos:
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: macos-latest
    env:
      NEW_VERSION: ${{ needs.release.outputs.new_version }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Build macOS binary
        run: cargo build --release --bin atento-cli

      - name: Rename binary to "atento"
        run: |
          shopt -s nullglob
          if compgen -G "target/release/atento-cli*" > /dev/null; then
            for file in target/release/atento-cli*; do
              mv "$file" "${file/atento-cli/atento}"
            done
          else
            echo "‚ö†Ô∏è No binaries found in target/release"
          fi

      - name: Upload macOS binary
        uses: actions/upload-artifact@v4
        with:
          name: atento-macos-${{ env.NEW_VERSION }}
          path: target/release/atento*
          if-no-files-found: error


  create-release:
    if: success() && github.ref == 'refs/heads/main'
    needs: [build-linux-windows, build-macos]
    runs-on: ubuntu-latest
    env:
      NEW_VERSION: ${{ needs.release.outputs.new_version }}
    permissions:
      contents: write # Ensure permissions are set here too, or globally at the job level

    steps:
      - uses: actions/checkout@v4
      
      # Download all artifacts from the build jobs
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts into their respective directories
          path: artifacts/

      # We need the tag to exist before creating the release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          name: "Release v${{ env.NEW_VERSION }}"
          # Get all built artifacts to attach to the release
          files: target/*/*/release/atento*
