name: Release Workflow

on:
  # Triggers on push to main
  push:
    branches: [main]
  # Allows manual runs for testing
  workflow_dispatch:

env:
  # Use the standard GITHUB_TOKEN for actions requiring repo write/read access
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  # Variable to hold the calculated new version
  NEW_VERSION: ""

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write # Needed for committing, pushing tags, and creating releases

    steps:
      # ------------------------------
      # 1. Checkout & Setup Rust
      # ------------------------------
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # IMPORTANT: Fetch all history and tags for versioning logic

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          profile: minimal
          override: true
          components: rustfmt, clippy

      - name: Cache cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-

      - name: Install tools
        run: cargo install cargo-edit

      # --- Code Quality: rustfmt (Style Check) ---
      - name: ðŸ“ Run cargo fmt check
        run: cargo fmt --all --check
        # The '--check' flag ensures the job fails if formatting is required.
 
      # --- Code Quality: clippy (Linting) ---
      - name: ðŸ§¹ Run cargo clippy
        run: cargo clippy --all-targets --all-features -- -D warnings
        # The '-D warnings' flag makes the CI fail on any warning.

      # --- Code Coverage (using cargo-tarpaulin) ---
      - name: ðŸš€ Install cargo-tarpaulin
        run: cargo install cargo-tarpaulin

      - name: ðŸ§ª Run tests and collect coverage
        run: cargo tarpaulin --verbose --out Xml --ignore-tests
        # Tarpaulin defaults to placing the XML report here:
        # target/tarpaulin/cobertura.xml

      - name: ðŸ“ Publish Coverage Report to GitHub Summary ðŸš€
        uses: MishaKav/pytest-coverage-comment@main
        with:
          # The path to the Cobertura XML file generated by tarpaulin
          coverage-path: target/tarpaulin/cobertura.xml
          # Set report format to cobertura
          coverage-format: cobertura
          # Optional: Define minimum coverage percentage to pass the check
          minimum-coverage: 80
          # Optional: Comment mode (default is 'replace')
          title: Code Coverage Report ðŸ“ˆ

      # run all unit tests for the workspace
      - name: Run unit tests and check code quality
        run: cargo test --workspace --lib --all-features

      # ------------------------------
      # 2. Determine and Bump Version (Commit-based Conventional Commit Analysis)
      # ------------------------------
      - name: Determine bump type
        id: bump_version
        run: |          
          # 1. Find the last tag to look for changes since
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Last Tag: $LAST_TAG"

          # 2. Analyze commits since the last tag for Conventional Commit type
          COMMIT_LOG=$(git log --pretty=format:%s $LAST_TAG..HEAD)
          BUMP_TYPE="patch"

          if echo "$COMMIT_LOG" | grep -q "BREAKING CHANGE"; then
            BUMP_TYPE="major"
          elif echo "$COMMIT_LOG" | grep -q "^feat"; then
            BUMP_TYPE="minor"
          elif echo "$COMMIT_LOG" | grep -q "^fix"; then
            BUMP_TYPE="patch"
          fi
          
          # Fallback if no specific type is found, ensure a bump happens for the push.
          if [ "$BUMP_TYPE" == "patch" ] && ! echo "$COMMIT_LOG" | grep -qE "^feat|^fix"; then
              BUMP_TYPE="patch"
          fi

          echo "Determined Bump Type: $BUMP_TYPE"

          # Strip the 'v' prefix and remove any trailing control characters (like \r)
          VERSION_CLEANED="${LAST_TAG#v}"
          VERSION_CLEANED=$(echo "$VERSION_CLEANED" | tr -d '\r') # Use tr to strip \r

          # 3. Calculate the new version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_CLEANED"
 
          # Explicitly remove leading zeros and ensure default is 0
          MAJOR=$((10#${MAJOR:-0}))
          MINOR=$((10#${MINOR:-0}))
          PATCH=$((10#${PATCH:-0}))

          case $BUMP_TYPE in
            patch) PATCH=$((PATCH + 1));;
            minor) MINOR=$((MINOR + 1)); PATCH=0;;
            major) MAJOR=$((MAJOR + 1)); MINOR=0; PATCH=0;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "Calculated New Version: $NEW_VERSION"

      # 3. Bump versions in Cargo.toml files
      - name: Bump versions
        run: |
          cargo set-version $NEW_VERSION --manifest-path atento-core/Cargo.toml
          cargo set-version $NEW_VERSION --manifest-path atento-cli/Cargo.toml

  # --- Build Jobs Now Depend on the Tag being Pushed ---
  # These jobs should now be triggered by the new tag push (if you add a tag trigger), 
  # but since they depend on the 'release' job, they will run immediately.
  build-linux-windows:
    # Use condition to only run if a new version was set and the current ref is 'main'
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable          
          override: true
      - run: cargo install cross
      # Linux builds
      - run: cross build --release --target x86_64-unknown-linux-musl --bin atento-cli --target-dir target/x86_64-unknown-linux-musl
      - run: cross build --release --target aarch64-unknown-linux-musl --bin atento-cli --target-dir target/aarch64-unknown-linux-musl
      # Windows builds
      - run: cross build --release --target x86_64-pc-windows-gnu --bin atento-cli --target-dir target/x86_64-pc-windows-gnu
      # Rename binaries
      - run: |
          for dir in target/*/*/release; do
            for file in $dir/atento-cli*; do
              mv "$file" "${file/atento-cli/atento}"
            done
          done

  build-macos:
    if: success() && github.ref == 'refs/heads/main'
    needs: [release]
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true
      - run: cargo build --release --target aarch64-apple-darwin --bin atento-cli --target-dir target/aarch64-apple-darwin
      - run: |
          for dir in target/*/*/release; do
            if ls $dir/atento-cli* 1> /dev/null 2>&1; then
              for file in $dir/atento-cli*; do
                mv "$file" "${file/atento-cli/atento}"
              done
            else
              echo "âš ï¸ No binaries found in $dir, skipping."
            fi
          done

  create-release:
    if: success() && github.ref == 'refs/heads/main'
    needs: [build-linux-windows, build-macos]
    runs-on: ubuntu-latest
    permissions:
      contents: write # Ensure permissions are set here too, or globally at the job level

    steps:
      - uses: actions/checkout@v4
      
      # ðŸ’¡ FIX B: Access the NEW_VERSION output from the 'release' job
      - name: Set NEW_VERSION for current job
        run: |
          echo "NEW_VERSION=${{ needs.release.outputs.new_version }}" >> $GITHUB_ENV
          
      # ðŸ’¡ FIX A: Download all artifacts from the build jobs
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          # Downloads all artifacts into their respective directories
          path: artifacts/

      # Commit and Tag the new version
      - name: Commit & push version bump
        run: |
          # Use GitHub's standard commit user
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          # Re-bump versions using the output from the 'release' job
          cargo install cargo-edit # install tool again
          cargo set-version $NEW_VERSION --manifest-path atento-core/Cargo.toml
          cargo set-version $NEW_VERSION --manifest-path atento-cli/Cargo.toml
          
          git add atento-core/Cargo.toml atento-cli/Cargo.toml
          git commit -m "chore(release): Bump version to v$NEW_VERSION"
          git tag v$NEW_VERSION

          # Push the commit and the tag
          git push origin main
          git push origin v$NEW_VERSION

      # ------------------------------
      # Publish Crate (This only runs on the initial successful push)
      # ------------------------------
      - name: Publish core to crates.io
        # Note: This step is robustly run on the *initial* push, not the bump commit
        uses: actions-rs/cargo@v1
        with:
          command: publish
          manifest-path: atento-core/Cargo.toml
          token: ${{ secrets.CARGO_TOKEN }}
          args: --allow-dirty # Allow publishing after the commit/tag step

      # We need the tag to exist before creating the release
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.NEW_VERSION }}
          name: "Release v${{ env.NEW_VERSION }}"
          # Get all built artifacts to attach to the release
          files: target/*/*/release/atento*
